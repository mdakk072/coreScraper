<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>core.utils API documentation</title>
<meta name="description" content="utils.py â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>core.utils</code></h1>
</header>
<section id="section-intro">
<p>utils.py</p>
<p>This module provides utility functions for common tasks such as file I/O,
logging, and timestamp generation. The Utils class offers various static methods
for interacting with YAML and JSON files, setting up logging, creating directories,
and generating timestamps. These utilities are designed to simplify the development
of web scraping projects and other applications that require basic file and logging
operations.</p>
<p>Author: mdakk072</p>
<p>Date: 5 May 2024</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
utils.py

This module provides utility functions for common tasks such as file I/O,
logging, and timestamp generation. The Utils class offers various static methods
for interacting with YAML and JSON files, setting up logging, creating directories,
and generating timestamps. These utilities are designed to simplify the development
of web scraping projects and other applications that require basic file and logging
operations.

Author: mdakk072

Date: 5 May 2024
&#34;&#34;&#34;

import logging
import os
import yaml
import json
import xml.etree.ElementTree as ET
import configparser

class Utils:
    &#34;&#34;&#34;
    A utility class for common operations such as file I/O, logging, and timestamp generation.

    The Utils class provides static methods for handling YAML and JSON files,
    setting up logging, creating directories, and generating timestamps. These
    utilities are designed to be reusable across different projects.

    Attributes:
        _logger (logging.Logger): The class-level logger instance used for logging.
    &#34;&#34;&#34;
    _logger = None  # Class-level attribute to hold the logger
    
    @staticmethod
    def setup_logging(file_path=&#39;data/logs/app.log&#39;, debug=False, console_logging=True, file_logging=True):
        &#34;&#34;&#34;
        Configure and return a logger instance.

        Sets up logging for the application, outputting messages to both console and a log file.
        The logging level is determined by the `debug` parameter. If a logger already exists,
        it returns the existing logger.

        Args:
            file_path (str): The file path where logs should be saved. Defaults to &#39;data/log/app.log&#39;.
            debug (bool): Flag to indicate whether to show debug messages. Defaults to False.
            console_logging (bool): Flag to indicate whether to log to the console. Defaults to True.
            file_logging (bool): Flag to indicate whether to log to a file. Defaults to True.

        Returns:
            logging.Logger: The configured logger instance.
        &#34;&#34;&#34;
        # Check if logger already exists to avoid multiple handlers
        if Utils._logger is not None:
            return Utils._logger

        # Create a custom logger
        Utils._logger = logging.getLogger(__name__)
        Utils._logger.setLevel(logging.DEBUG if debug else logging.INFO)

        log_format = &#39;[%(asctime)s] [%(levelname)s] [%(module)s.%(funcName)s:%(lineno)d] : %(message)s&#39;
        formatter = logging.Formatter(log_format, datefmt=&#39;%d-%m-%Y %H:%M:%S&#39;)

        # Create console handler if enabled
        if console_logging:
            c_handler = logging.StreamHandler()
            c_handler.setFormatter(formatter)
            Utils._logger.addHandler(c_handler)

        # Create file handler if enabled
        if file_logging:
            logs_folder = os.path.dirname(file_path)
            if not os.path.exists(logs_folder):
                os.makedirs(logs_folder)
            f_handler = logging.FileHandler(file_path)
            f_handler.setFormatter(formatter)
            Utils._logger.addHandler(f_handler)

        return Utils._logger
    
    @staticmethod
    def get_logger():
        &#34;&#34;&#34;
        Retrieve logger instance.

        If the logger has not been set up, this method will initialize it with
        default settings and issue a warning indicating that it wasn&#39;t set up
        beforehand.

        Returns:
            logging.Logger: The logger instance for the current context.
        &#34;&#34;&#34;
        if Utils._logger is None:
            # Logger is not set up, set it up with default settings
            Utils._logger = Utils.setup_logging()
            Utils._logger.warning(&#34;Logger was not set up. Please set it up before using it,using default settings.&#34;)
        return Utils._logger
    
    @staticmethod
    def read_yaml(file_path):
        &#34;&#34;&#34;
        Read and parse a YAML file.

        This method reads a YAML file from the specified file path and returns its contents.
        If the file is not found or cannot be parsed, it logs an error message and returns None.

        Args:
            file_path (str): The path to the YAML file.

        Returns:
            dict or list or None: The parsed contents of the YAML file, or None if an error occurred.
        &#34;&#34;&#34;
        try:
            # Open the file and parse its contents
            with open(file_path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as file:
                return yaml.safe_load(file)
        except FileNotFoundError:
            # Log an error if the file is not found
            logging.error(&#34;The file was not found: %s&#34;, file_path)
            return None
        except yaml.YAMLError as exc:
            # Log an error if there is an issue parsing the file
            logging.error(&#34;Error while parsing YAML file: %s&#34;, exc)
            return None
        
    @staticmethod
    def write_yaml(data, file_path):
        &#34;&#34;&#34;
        Write data to a YAML file.

        This method writes the provided data to a YAML file at the specified file path.
        If an error occurs during writing, it logs an error message and returns False.

        Args:
            data (dict or list): The data to be written to the YAML file.
            file_path (str): The path where the YAML file will be saved.

        Returns:
            bool: True if the data was successfully written to the YAML file, False otherwise.
        &#34;&#34;&#34;
        try:
            # Ensure the directory exists
            directory = os.path.dirname(file_path)
            if not os.path.exists(directory):
                os.makedirs(directory)

            # Open the file and write the data to it
            with open(file_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
                yaml.safe_dump(data, file, default_flow_style=False, allow_unicode=True)
            return True
        except IOError as exc:
            # Log an error if there is an issue writing to the file
            logging.error(&#34;Error while writing to YAML file: %s&#34;, exc)
            return False
        except yaml.YAMLError as exc:
            # Log an error if there is an issue with the YAML data
            logging.error(&#34;Error while dumping data to YAML file: %s&#34;, exc)
            return False

    @staticmethod
    def read_json(file_path):
        &#34;&#34;&#34;
        Read and parse a JSON file.

        This method reads a JSON file from the specified file path and returns its contents.
        If the file is not found or cannot be parsed, it logs an error message and returns None.

        Args:
            file_path (str): The path to the JSON file.

        Returns:
            dict or list or None: The parsed contents of the JSON file, or None if an error occurred.
        &#34;&#34;&#34;
        try:
            # Open the file and parse its contents
            with open(file_path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as file:
                return json.load(file)
        except FileNotFoundError:
            logging.error(&#34;The file was not found: %s&#34;, file_path)
            return None
        except json.JSONDecodeError as exc:
            logging.error(&#34;Error while parsing JSON file: %s&#34;, exc)
            return None

    @staticmethod
    def write_json(data, file_path):
        &#34;&#34;&#34;
        Write data to a JSON file.

        This method writes the provided data to a JSON file at the specified file path.
        If an error occurs during writing, it logs an error message and returns False.

        Args:
            data (dict or list): The data to be written to the JSON file.
            file_path (str): The path where the JSON file will be saved.

        Returns:
            bool: True if the data was successfully written to the JSON file, False otherwise.
        &#34;&#34;&#34;
        try:
            # Ensure the directory exists
            directory = os.path.dirname(file_path)
            if not os.path.exists(directory):
                os.makedirs(directory)

            # Open the file and write the data to it
            with open(file_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
                json.dump(data, file, ensure_ascii=False, indent=4)
            return True
        except IOError as exc:
            logging.error(&#34;Error while writing to JSON file: %s&#34;, exc)
            return False

    @staticmethod
    def read_ini(file_path):
        &#34;&#34;&#34;
        Read and parse an INI file.

        This method reads an INI file from the specified file path and returns its contents as a dictionary.
        If the file is not found or cannot be parsed, it logs an error message and returns None.

        Args:
            file_path (str): The path to the INI file.

        Returns:
            dict or None: The parsed contents of the INI file, or None if an error occurred.
        &#34;&#34;&#34;
        config = configparser.ConfigParser()
        try:
            # Open the file and parse its contents
            config.read(file_path, encoding=&#39;utf-8&#39;)
            return {section: dict(config.items(section)) for section in config.sections()}
        except FileNotFoundError:
            logging.error(&#34;The file was not found: %s&#34;, file_path)
            return None
        except configparser.Error as exc:
            logging.error(&#34;Error while parsing INI file: %s&#34;, exc)
            return None

    @staticmethod
    def write_ini(data, file_path):
        &#34;&#34;&#34;
        Write data to an INI file.

        This method writes the provided data to an INI file at the specified file path.
        If an error occurs during writing, it logs an error message and returns False.

        Args:
            data (dict): The data to be written to the INI file.
            file_path (str): The path where the INI file will be saved.

        Returns:
            bool: True if the data was successfully written to the INI file, False otherwise.
        &#34;&#34;&#34;
    
        config = configparser.ConfigParser()
        for section, values in data.items():
            config[section] = values

        try:
            # Ensure the directory exists
            directory = os.path.dirname(file_path)
            if not os.path.exists(directory):
                os.makedirs(directory)

            # Open the file and write the data to it
            with open(file_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
                config.write(file)
            return True
        except IOError as exc:
            logging.error(&#34;Error while writing to INI file: %s&#34;, exc)
            return False

    @staticmethod
    def read_xml(file_path):
        &#34;&#34;&#34;
        Read and parse an XML file.

        This method reads an XML file from the specified file path and returns its contents as an ElementTree object.
        If the file is not found or cannot be parsed, it logs an error message and returns None.

        Args:
            file_path (str): The path to the XML file.

        Returns:
            ET.ElementTree or None: The parsed contents of the XML file, or None if an error occurred.
        &#34;&#34;&#34;
        try:
            # Open the file and parse its contents
            return ET.parse(file_path)
        except FileNotFoundError:
            logging.error(&#34;The file was not found: %s&#34;, file_path)
            return None
        except ET.ParseError as exc:
            logging.error(&#34;Error while parsing XML file: %s&#34;, exc)
            return None

    @staticmethod
    def write_xml(data, file_path):
        &#34;&#34;&#34;
        Write data to an XML file.

        This method writes the provided data to an XML file at the specified file path.
        If an error occurs during writing, it logs an error message and returns False.

        Args:
            data (ET.ElementTree): The data to be written to the XML file.
            file_path (str): The path where the XML file will be saved.

        Returns:
            bool: True if the data was successfully written to the XML file, False otherwise.
        &#34;&#34;&#34;
        try:
            # Ensure the directory exists
            directory = os.path.dirname(file_path)
            if not os.path.exists(directory):
                os.makedirs(directory)

            # Write the data to the file
            data.write(file_path, encoding=&#39;utf-8&#39;, xml_declaration=True)
            return True
        except IOError as exc:
            logging.error(&#34;Error while writing to XML file: %s&#34;, exc)
            return False
        except ET.ElementTree as exc:
            logging.error(&#34;Error while creating XML file: %s&#34;, exc)
            return False

    @staticmethod
    def read_file(file_path, as_lines=False, encoding=&#39;utf-8&#39;):
        &#34;&#34;&#34;
        Read and return the contents of a file.

        This method reads the contents of a file from the specified file path and returns 
        it either as a string or as a list of lines. If the file is not found or cannot 
        be read, it logs an error message and returns None.

        Args:
            file_path (str): The path to the file.
            as_lines (bool): Flag to indicate whether to return lines. Defaults to False.
            encoding (str): The encoding of the file. Defaults to &#39;utf-8&#39;.

        Returns:
            str or list of str or None: The contents of the file, or None if an error occurred.
        &#34;&#34;&#34;
        try:
            # Open the file and read its contents
            with open(file_path, &#39;r&#39;, encoding=encoding) as file:
                return file.readlines() if as_lines else file.read()
        except FileNotFoundError:
            logging.error(&#34;The file was not found: %s&#34;, file_path)
            return None
        except IOError as exc:
            logging.error(&#34;Error while reading file: %s&#34;, exc)
            return None

    @staticmethod
    def write_file(data, file_path, mode=&#39;w&#39;, encoding=&#39;utf-8&#39;):
        &#34;&#34;&#34;
        Write data to a file.

        This method writes the provided data to a file at the specified file path.
        The mode can be specified to determine whether to overwrite or append to the file.
        If an error occurs during writing, it logs an error message and returns False.

        Args:
            data (str): The data to be written to the file.
            file_path (str): The path where the file will be saved.
            mode (str): The mode for writing the file. Defaults to &#39;w&#39; (overwrite).
            encoding (str): The encoding of the file. Defaults to &#39;utf-8&#39;.

        Returns:
            bool: True if the data was successfully written to the file, False otherwise.
        &#34;&#34;&#34;
        try:
            # Ensure the directory exists
            directory = os.path.dirname(file_path)
            if not os.path.exists(directory):
                os.makedirs(directory)

            # Open the file and write the data to it
            with open(file_path, mode, encoding=encoding) as file:
                file.write(data)
            return True
        except IOError as exc:
            logging.error(&#34;Error while writing to file: %s&#34;, exc)
            return False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="core.utils.Utils"><code class="flex name class">
<span>class <span class="ident">Utils</span></span>
</code></dt>
<dd>
<div class="desc"><p>A utility class for common operations such as file I/O, logging, and timestamp generation.</p>
<p>The Utils class provides static methods for handling YAML and JSON files,
setting up logging, creating directories, and generating timestamps. These
utilities are designed to be reusable across different projects.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>_logger</code></strong> :&ensp;<code>logging.Logger</code></dt>
<dd>The class-level logger instance used for logging.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Utils:
    &#34;&#34;&#34;
    A utility class for common operations such as file I/O, logging, and timestamp generation.

    The Utils class provides static methods for handling YAML and JSON files,
    setting up logging, creating directories, and generating timestamps. These
    utilities are designed to be reusable across different projects.

    Attributes:
        _logger (logging.Logger): The class-level logger instance used for logging.
    &#34;&#34;&#34;
    _logger = None  # Class-level attribute to hold the logger
    
    @staticmethod
    def setup_logging(file_path=&#39;data/logs/app.log&#39;, debug=False, console_logging=True, file_logging=True):
        &#34;&#34;&#34;
        Configure and return a logger instance.

        Sets up logging for the application, outputting messages to both console and a log file.
        The logging level is determined by the `debug` parameter. If a logger already exists,
        it returns the existing logger.

        Args:
            file_path (str): The file path where logs should be saved. Defaults to &#39;data/log/app.log&#39;.
            debug (bool): Flag to indicate whether to show debug messages. Defaults to False.
            console_logging (bool): Flag to indicate whether to log to the console. Defaults to True.
            file_logging (bool): Flag to indicate whether to log to a file. Defaults to True.

        Returns:
            logging.Logger: The configured logger instance.
        &#34;&#34;&#34;
        # Check if logger already exists to avoid multiple handlers
        if Utils._logger is not None:
            return Utils._logger

        # Create a custom logger
        Utils._logger = logging.getLogger(__name__)
        Utils._logger.setLevel(logging.DEBUG if debug else logging.INFO)

        log_format = &#39;[%(asctime)s] [%(levelname)s] [%(module)s.%(funcName)s:%(lineno)d] : %(message)s&#39;
        formatter = logging.Formatter(log_format, datefmt=&#39;%d-%m-%Y %H:%M:%S&#39;)

        # Create console handler if enabled
        if console_logging:
            c_handler = logging.StreamHandler()
            c_handler.setFormatter(formatter)
            Utils._logger.addHandler(c_handler)

        # Create file handler if enabled
        if file_logging:
            logs_folder = os.path.dirname(file_path)
            if not os.path.exists(logs_folder):
                os.makedirs(logs_folder)
            f_handler = logging.FileHandler(file_path)
            f_handler.setFormatter(formatter)
            Utils._logger.addHandler(f_handler)

        return Utils._logger
    
    @staticmethod
    def get_logger():
        &#34;&#34;&#34;
        Retrieve logger instance.

        If the logger has not been set up, this method will initialize it with
        default settings and issue a warning indicating that it wasn&#39;t set up
        beforehand.

        Returns:
            logging.Logger: The logger instance for the current context.
        &#34;&#34;&#34;
        if Utils._logger is None:
            # Logger is not set up, set it up with default settings
            Utils._logger = Utils.setup_logging()
            Utils._logger.warning(&#34;Logger was not set up. Please set it up before using it,using default settings.&#34;)
        return Utils._logger
    
    @staticmethod
    def read_yaml(file_path):
        &#34;&#34;&#34;
        Read and parse a YAML file.

        This method reads a YAML file from the specified file path and returns its contents.
        If the file is not found or cannot be parsed, it logs an error message and returns None.

        Args:
            file_path (str): The path to the YAML file.

        Returns:
            dict or list or None: The parsed contents of the YAML file, or None if an error occurred.
        &#34;&#34;&#34;
        try:
            # Open the file and parse its contents
            with open(file_path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as file:
                return yaml.safe_load(file)
        except FileNotFoundError:
            # Log an error if the file is not found
            logging.error(&#34;The file was not found: %s&#34;, file_path)
            return None
        except yaml.YAMLError as exc:
            # Log an error if there is an issue parsing the file
            logging.error(&#34;Error while parsing YAML file: %s&#34;, exc)
            return None
        
    @staticmethod
    def write_yaml(data, file_path):
        &#34;&#34;&#34;
        Write data to a YAML file.

        This method writes the provided data to a YAML file at the specified file path.
        If an error occurs during writing, it logs an error message and returns False.

        Args:
            data (dict or list): The data to be written to the YAML file.
            file_path (str): The path where the YAML file will be saved.

        Returns:
            bool: True if the data was successfully written to the YAML file, False otherwise.
        &#34;&#34;&#34;
        try:
            # Ensure the directory exists
            directory = os.path.dirname(file_path)
            if not os.path.exists(directory):
                os.makedirs(directory)

            # Open the file and write the data to it
            with open(file_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
                yaml.safe_dump(data, file, default_flow_style=False, allow_unicode=True)
            return True
        except IOError as exc:
            # Log an error if there is an issue writing to the file
            logging.error(&#34;Error while writing to YAML file: %s&#34;, exc)
            return False
        except yaml.YAMLError as exc:
            # Log an error if there is an issue with the YAML data
            logging.error(&#34;Error while dumping data to YAML file: %s&#34;, exc)
            return False

    @staticmethod
    def read_json(file_path):
        &#34;&#34;&#34;
        Read and parse a JSON file.

        This method reads a JSON file from the specified file path and returns its contents.
        If the file is not found or cannot be parsed, it logs an error message and returns None.

        Args:
            file_path (str): The path to the JSON file.

        Returns:
            dict or list or None: The parsed contents of the JSON file, or None if an error occurred.
        &#34;&#34;&#34;
        try:
            # Open the file and parse its contents
            with open(file_path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as file:
                return json.load(file)
        except FileNotFoundError:
            logging.error(&#34;The file was not found: %s&#34;, file_path)
            return None
        except json.JSONDecodeError as exc:
            logging.error(&#34;Error while parsing JSON file: %s&#34;, exc)
            return None

    @staticmethod
    def write_json(data, file_path):
        &#34;&#34;&#34;
        Write data to a JSON file.

        This method writes the provided data to a JSON file at the specified file path.
        If an error occurs during writing, it logs an error message and returns False.

        Args:
            data (dict or list): The data to be written to the JSON file.
            file_path (str): The path where the JSON file will be saved.

        Returns:
            bool: True if the data was successfully written to the JSON file, False otherwise.
        &#34;&#34;&#34;
        try:
            # Ensure the directory exists
            directory = os.path.dirname(file_path)
            if not os.path.exists(directory):
                os.makedirs(directory)

            # Open the file and write the data to it
            with open(file_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
                json.dump(data, file, ensure_ascii=False, indent=4)
            return True
        except IOError as exc:
            logging.error(&#34;Error while writing to JSON file: %s&#34;, exc)
            return False

    @staticmethod
    def read_ini(file_path):
        &#34;&#34;&#34;
        Read and parse an INI file.

        This method reads an INI file from the specified file path and returns its contents as a dictionary.
        If the file is not found or cannot be parsed, it logs an error message and returns None.

        Args:
            file_path (str): The path to the INI file.

        Returns:
            dict or None: The parsed contents of the INI file, or None if an error occurred.
        &#34;&#34;&#34;
        config = configparser.ConfigParser()
        try:
            # Open the file and parse its contents
            config.read(file_path, encoding=&#39;utf-8&#39;)
            return {section: dict(config.items(section)) for section in config.sections()}
        except FileNotFoundError:
            logging.error(&#34;The file was not found: %s&#34;, file_path)
            return None
        except configparser.Error as exc:
            logging.error(&#34;Error while parsing INI file: %s&#34;, exc)
            return None

    @staticmethod
    def write_ini(data, file_path):
        &#34;&#34;&#34;
        Write data to an INI file.

        This method writes the provided data to an INI file at the specified file path.
        If an error occurs during writing, it logs an error message and returns False.

        Args:
            data (dict): The data to be written to the INI file.
            file_path (str): The path where the INI file will be saved.

        Returns:
            bool: True if the data was successfully written to the INI file, False otherwise.
        &#34;&#34;&#34;
    
        config = configparser.ConfigParser()
        for section, values in data.items():
            config[section] = values

        try:
            # Ensure the directory exists
            directory = os.path.dirname(file_path)
            if not os.path.exists(directory):
                os.makedirs(directory)

            # Open the file and write the data to it
            with open(file_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
                config.write(file)
            return True
        except IOError as exc:
            logging.error(&#34;Error while writing to INI file: %s&#34;, exc)
            return False

    @staticmethod
    def read_xml(file_path):
        &#34;&#34;&#34;
        Read and parse an XML file.

        This method reads an XML file from the specified file path and returns its contents as an ElementTree object.
        If the file is not found or cannot be parsed, it logs an error message and returns None.

        Args:
            file_path (str): The path to the XML file.

        Returns:
            ET.ElementTree or None: The parsed contents of the XML file, or None if an error occurred.
        &#34;&#34;&#34;
        try:
            # Open the file and parse its contents
            return ET.parse(file_path)
        except FileNotFoundError:
            logging.error(&#34;The file was not found: %s&#34;, file_path)
            return None
        except ET.ParseError as exc:
            logging.error(&#34;Error while parsing XML file: %s&#34;, exc)
            return None

    @staticmethod
    def write_xml(data, file_path):
        &#34;&#34;&#34;
        Write data to an XML file.

        This method writes the provided data to an XML file at the specified file path.
        If an error occurs during writing, it logs an error message and returns False.

        Args:
            data (ET.ElementTree): The data to be written to the XML file.
            file_path (str): The path where the XML file will be saved.

        Returns:
            bool: True if the data was successfully written to the XML file, False otherwise.
        &#34;&#34;&#34;
        try:
            # Ensure the directory exists
            directory = os.path.dirname(file_path)
            if not os.path.exists(directory):
                os.makedirs(directory)

            # Write the data to the file
            data.write(file_path, encoding=&#39;utf-8&#39;, xml_declaration=True)
            return True
        except IOError as exc:
            logging.error(&#34;Error while writing to XML file: %s&#34;, exc)
            return False
        except ET.ElementTree as exc:
            logging.error(&#34;Error while creating XML file: %s&#34;, exc)
            return False

    @staticmethod
    def read_file(file_path, as_lines=False, encoding=&#39;utf-8&#39;):
        &#34;&#34;&#34;
        Read and return the contents of a file.

        This method reads the contents of a file from the specified file path and returns 
        it either as a string or as a list of lines. If the file is not found or cannot 
        be read, it logs an error message and returns None.

        Args:
            file_path (str): The path to the file.
            as_lines (bool): Flag to indicate whether to return lines. Defaults to False.
            encoding (str): The encoding of the file. Defaults to &#39;utf-8&#39;.

        Returns:
            str or list of str or None: The contents of the file, or None if an error occurred.
        &#34;&#34;&#34;
        try:
            # Open the file and read its contents
            with open(file_path, &#39;r&#39;, encoding=encoding) as file:
                return file.readlines() if as_lines else file.read()
        except FileNotFoundError:
            logging.error(&#34;The file was not found: %s&#34;, file_path)
            return None
        except IOError as exc:
            logging.error(&#34;Error while reading file: %s&#34;, exc)
            return None

    @staticmethod
    def write_file(data, file_path, mode=&#39;w&#39;, encoding=&#39;utf-8&#39;):
        &#34;&#34;&#34;
        Write data to a file.

        This method writes the provided data to a file at the specified file path.
        The mode can be specified to determine whether to overwrite or append to the file.
        If an error occurs during writing, it logs an error message and returns False.

        Args:
            data (str): The data to be written to the file.
            file_path (str): The path where the file will be saved.
            mode (str): The mode for writing the file. Defaults to &#39;w&#39; (overwrite).
            encoding (str): The encoding of the file. Defaults to &#39;utf-8&#39;.

        Returns:
            bool: True if the data was successfully written to the file, False otherwise.
        &#34;&#34;&#34;
        try:
            # Ensure the directory exists
            directory = os.path.dirname(file_path)
            if not os.path.exists(directory):
                os.makedirs(directory)

            # Open the file and write the data to it
            with open(file_path, mode, encoding=encoding) as file:
                file.write(data)
            return True
        except IOError as exc:
            logging.error(&#34;Error while writing to file: %s&#34;, exc)
            return False</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="core.utils.Utils.get_logger"><code class="name flex">
<span>def <span class="ident">get_logger</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve logger instance.</p>
<p>If the logger has not been set up, this method will initialize it with
default settings and issue a warning indicating that it wasn't set up
beforehand.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>logging.Logger</code></dt>
<dd>The logger instance for the current context.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_logger():
    &#34;&#34;&#34;
    Retrieve logger instance.

    If the logger has not been set up, this method will initialize it with
    default settings and issue a warning indicating that it wasn&#39;t set up
    beforehand.

    Returns:
        logging.Logger: The logger instance for the current context.
    &#34;&#34;&#34;
    if Utils._logger is None:
        # Logger is not set up, set it up with default settings
        Utils._logger = Utils.setup_logging()
        Utils._logger.warning(&#34;Logger was not set up. Please set it up before using it,using default settings.&#34;)
    return Utils._logger</code></pre>
</details>
</dd>
<dt id="core.utils.Utils.read_file"><code class="name flex">
<span>def <span class="ident">read_file</span></span>(<span>file_path, as_lines=False, encoding='utf-8')</span>
</code></dt>
<dd>
<div class="desc"><p>Read and return the contents of a file.</p>
<p>This method reads the contents of a file from the specified file path and returns
it either as a string or as a list of lines. If the file is not found or cannot
be read, it logs an error message and returns None.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the file.</dd>
<dt><strong><code>as_lines</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag to indicate whether to return lines. Defaults to False.</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code></dt>
<dd>The encoding of the file. Defaults to 'utf-8'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code> or <code>list</code> of <code>str</code> or <code>None</code></dt>
<dd>The contents of the file, or None if an error occurred.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read_file(file_path, as_lines=False, encoding=&#39;utf-8&#39;):
    &#34;&#34;&#34;
    Read and return the contents of a file.

    This method reads the contents of a file from the specified file path and returns 
    it either as a string or as a list of lines. If the file is not found or cannot 
    be read, it logs an error message and returns None.

    Args:
        file_path (str): The path to the file.
        as_lines (bool): Flag to indicate whether to return lines. Defaults to False.
        encoding (str): The encoding of the file. Defaults to &#39;utf-8&#39;.

    Returns:
        str or list of str or None: The contents of the file, or None if an error occurred.
    &#34;&#34;&#34;
    try:
        # Open the file and read its contents
        with open(file_path, &#39;r&#39;, encoding=encoding) as file:
            return file.readlines() if as_lines else file.read()
    except FileNotFoundError:
        logging.error(&#34;The file was not found: %s&#34;, file_path)
        return None
    except IOError as exc:
        logging.error(&#34;Error while reading file: %s&#34;, exc)
        return None</code></pre>
</details>
</dd>
<dt id="core.utils.Utils.read_ini"><code class="name flex">
<span>def <span class="ident">read_ini</span></span>(<span>file_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Read and parse an INI file.</p>
<p>This method reads an INI file from the specified file path and returns its contents as a dictionary.
If the file is not found or cannot be parsed, it logs an error message and returns None.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the INI file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code> or <code>None</code></dt>
<dd>The parsed contents of the INI file, or None if an error occurred.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read_ini(file_path):
    &#34;&#34;&#34;
    Read and parse an INI file.

    This method reads an INI file from the specified file path and returns its contents as a dictionary.
    If the file is not found or cannot be parsed, it logs an error message and returns None.

    Args:
        file_path (str): The path to the INI file.

    Returns:
        dict or None: The parsed contents of the INI file, or None if an error occurred.
    &#34;&#34;&#34;
    config = configparser.ConfigParser()
    try:
        # Open the file and parse its contents
        config.read(file_path, encoding=&#39;utf-8&#39;)
        return {section: dict(config.items(section)) for section in config.sections()}
    except FileNotFoundError:
        logging.error(&#34;The file was not found: %s&#34;, file_path)
        return None
    except configparser.Error as exc:
        logging.error(&#34;Error while parsing INI file: %s&#34;, exc)
        return None</code></pre>
</details>
</dd>
<dt id="core.utils.Utils.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>file_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Read and parse a JSON file.</p>
<p>This method reads a JSON file from the specified file path and returns its contents.
If the file is not found or cannot be parsed, it logs an error message and returns None.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the JSON file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code> or <code>list</code> or <code>None</code></dt>
<dd>The parsed contents of the JSON file, or None if an error occurred.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read_json(file_path):
    &#34;&#34;&#34;
    Read and parse a JSON file.

    This method reads a JSON file from the specified file path and returns its contents.
    If the file is not found or cannot be parsed, it logs an error message and returns None.

    Args:
        file_path (str): The path to the JSON file.

    Returns:
        dict or list or None: The parsed contents of the JSON file, or None if an error occurred.
    &#34;&#34;&#34;
    try:
        # Open the file and parse its contents
        with open(file_path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as file:
            return json.load(file)
    except FileNotFoundError:
        logging.error(&#34;The file was not found: %s&#34;, file_path)
        return None
    except json.JSONDecodeError as exc:
        logging.error(&#34;Error while parsing JSON file: %s&#34;, exc)
        return None</code></pre>
</details>
</dd>
<dt id="core.utils.Utils.read_xml"><code class="name flex">
<span>def <span class="ident">read_xml</span></span>(<span>file_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Read and parse an XML file.</p>
<p>This method reads an XML file from the specified file path and returns its contents as an ElementTree object.
If the file is not found or cannot be parsed, it logs an error message and returns None.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the XML file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ET.ElementTree</code> or <code>None</code></dt>
<dd>The parsed contents of the XML file, or None if an error occurred.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read_xml(file_path):
    &#34;&#34;&#34;
    Read and parse an XML file.

    This method reads an XML file from the specified file path and returns its contents as an ElementTree object.
    If the file is not found or cannot be parsed, it logs an error message and returns None.

    Args:
        file_path (str): The path to the XML file.

    Returns:
        ET.ElementTree or None: The parsed contents of the XML file, or None if an error occurred.
    &#34;&#34;&#34;
    try:
        # Open the file and parse its contents
        return ET.parse(file_path)
    except FileNotFoundError:
        logging.error(&#34;The file was not found: %s&#34;, file_path)
        return None
    except ET.ParseError as exc:
        logging.error(&#34;Error while parsing XML file: %s&#34;, exc)
        return None</code></pre>
</details>
</dd>
<dt id="core.utils.Utils.read_yaml"><code class="name flex">
<span>def <span class="ident">read_yaml</span></span>(<span>file_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Read and parse a YAML file.</p>
<p>This method reads a YAML file from the specified file path and returns its contents.
If the file is not found or cannot be parsed, it logs an error message and returns None.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the YAML file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code> or <code>list</code> or <code>None</code></dt>
<dd>The parsed contents of the YAML file, or None if an error occurred.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read_yaml(file_path):
    &#34;&#34;&#34;
    Read and parse a YAML file.

    This method reads a YAML file from the specified file path and returns its contents.
    If the file is not found or cannot be parsed, it logs an error message and returns None.

    Args:
        file_path (str): The path to the YAML file.

    Returns:
        dict or list or None: The parsed contents of the YAML file, or None if an error occurred.
    &#34;&#34;&#34;
    try:
        # Open the file and parse its contents
        with open(file_path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as file:
            return yaml.safe_load(file)
    except FileNotFoundError:
        # Log an error if the file is not found
        logging.error(&#34;The file was not found: %s&#34;, file_path)
        return None
    except yaml.YAMLError as exc:
        # Log an error if there is an issue parsing the file
        logging.error(&#34;Error while parsing YAML file: %s&#34;, exc)
        return None</code></pre>
</details>
</dd>
<dt id="core.utils.Utils.setup_logging"><code class="name flex">
<span>def <span class="ident">setup_logging</span></span>(<span>file_path='data/logs/app.log', debug=False, console_logging=True, file_logging=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure and return a logger instance.</p>
<p>Sets up logging for the application, outputting messages to both console and a log file.
The logging level is determined by the <code>debug</code> parameter. If a logger already exists,
it returns the existing logger.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The file path where logs should be saved. Defaults to 'data/log/app.log'.</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag to indicate whether to show debug messages. Defaults to False.</dd>
<dt><strong><code>console_logging</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag to indicate whether to log to the console. Defaults to True.</dd>
<dt><strong><code>file_logging</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag to indicate whether to log to a file. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>logging.Logger</code></dt>
<dd>The configured logger instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def setup_logging(file_path=&#39;data/logs/app.log&#39;, debug=False, console_logging=True, file_logging=True):
    &#34;&#34;&#34;
    Configure and return a logger instance.

    Sets up logging for the application, outputting messages to both console and a log file.
    The logging level is determined by the `debug` parameter. If a logger already exists,
    it returns the existing logger.

    Args:
        file_path (str): The file path where logs should be saved. Defaults to &#39;data/log/app.log&#39;.
        debug (bool): Flag to indicate whether to show debug messages. Defaults to False.
        console_logging (bool): Flag to indicate whether to log to the console. Defaults to True.
        file_logging (bool): Flag to indicate whether to log to a file. Defaults to True.

    Returns:
        logging.Logger: The configured logger instance.
    &#34;&#34;&#34;
    # Check if logger already exists to avoid multiple handlers
    if Utils._logger is not None:
        return Utils._logger

    # Create a custom logger
    Utils._logger = logging.getLogger(__name__)
    Utils._logger.setLevel(logging.DEBUG if debug else logging.INFO)

    log_format = &#39;[%(asctime)s] [%(levelname)s] [%(module)s.%(funcName)s:%(lineno)d] : %(message)s&#39;
    formatter = logging.Formatter(log_format, datefmt=&#39;%d-%m-%Y %H:%M:%S&#39;)

    # Create console handler if enabled
    if console_logging:
        c_handler = logging.StreamHandler()
        c_handler.setFormatter(formatter)
        Utils._logger.addHandler(c_handler)

    # Create file handler if enabled
    if file_logging:
        logs_folder = os.path.dirname(file_path)
        if not os.path.exists(logs_folder):
            os.makedirs(logs_folder)
        f_handler = logging.FileHandler(file_path)
        f_handler.setFormatter(formatter)
        Utils._logger.addHandler(f_handler)

    return Utils._logger</code></pre>
</details>
</dd>
<dt id="core.utils.Utils.write_file"><code class="name flex">
<span>def <span class="ident">write_file</span></span>(<span>data, file_path, mode='w', encoding='utf-8')</span>
</code></dt>
<dd>
<div class="desc"><p>Write data to a file.</p>
<p>This method writes the provided data to a file at the specified file path.
The mode can be specified to determine whether to overwrite or append to the file.
If an error occurs during writing, it logs an error message and returns False.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code></dt>
<dd>The data to be written to the file.</dd>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path where the file will be saved.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The mode for writing the file. Defaults to 'w' (overwrite).</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code></dt>
<dd>The encoding of the file. Defaults to 'utf-8'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the data was successfully written to the file, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def write_file(data, file_path, mode=&#39;w&#39;, encoding=&#39;utf-8&#39;):
    &#34;&#34;&#34;
    Write data to a file.

    This method writes the provided data to a file at the specified file path.
    The mode can be specified to determine whether to overwrite or append to the file.
    If an error occurs during writing, it logs an error message and returns False.

    Args:
        data (str): The data to be written to the file.
        file_path (str): The path where the file will be saved.
        mode (str): The mode for writing the file. Defaults to &#39;w&#39; (overwrite).
        encoding (str): The encoding of the file. Defaults to &#39;utf-8&#39;.

    Returns:
        bool: True if the data was successfully written to the file, False otherwise.
    &#34;&#34;&#34;
    try:
        # Ensure the directory exists
        directory = os.path.dirname(file_path)
        if not os.path.exists(directory):
            os.makedirs(directory)

        # Open the file and write the data to it
        with open(file_path, mode, encoding=encoding) as file:
            file.write(data)
        return True
    except IOError as exc:
        logging.error(&#34;Error while writing to file: %s&#34;, exc)
        return False</code></pre>
</details>
</dd>
<dt id="core.utils.Utils.write_ini"><code class="name flex">
<span>def <span class="ident">write_ini</span></span>(<span>data, file_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Write data to an INI file.</p>
<p>This method writes the provided data to an INI file at the specified file path.
If an error occurs during writing, it logs an error message and returns False.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>The data to be written to the INI file.</dd>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path where the INI file will be saved.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the data was successfully written to the INI file, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def write_ini(data, file_path):
    &#34;&#34;&#34;
    Write data to an INI file.

    This method writes the provided data to an INI file at the specified file path.
    If an error occurs during writing, it logs an error message and returns False.

    Args:
        data (dict): The data to be written to the INI file.
        file_path (str): The path where the INI file will be saved.

    Returns:
        bool: True if the data was successfully written to the INI file, False otherwise.
    &#34;&#34;&#34;

    config = configparser.ConfigParser()
    for section, values in data.items():
        config[section] = values

    try:
        # Ensure the directory exists
        directory = os.path.dirname(file_path)
        if not os.path.exists(directory):
            os.makedirs(directory)

        # Open the file and write the data to it
        with open(file_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
            config.write(file)
        return True
    except IOError as exc:
        logging.error(&#34;Error while writing to INI file: %s&#34;, exc)
        return False</code></pre>
</details>
</dd>
<dt id="core.utils.Utils.write_json"><code class="name flex">
<span>def <span class="ident">write_json</span></span>(<span>data, file_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Write data to a JSON file.</p>
<p>This method writes the provided data to a JSON file at the specified file path.
If an error occurs during writing, it logs an error message and returns False.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code> or <code>list</code></dt>
<dd>The data to be written to the JSON file.</dd>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path where the JSON file will be saved.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the data was successfully written to the JSON file, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def write_json(data, file_path):
    &#34;&#34;&#34;
    Write data to a JSON file.

    This method writes the provided data to a JSON file at the specified file path.
    If an error occurs during writing, it logs an error message and returns False.

    Args:
        data (dict or list): The data to be written to the JSON file.
        file_path (str): The path where the JSON file will be saved.

    Returns:
        bool: True if the data was successfully written to the JSON file, False otherwise.
    &#34;&#34;&#34;
    try:
        # Ensure the directory exists
        directory = os.path.dirname(file_path)
        if not os.path.exists(directory):
            os.makedirs(directory)

        # Open the file and write the data to it
        with open(file_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
            json.dump(data, file, ensure_ascii=False, indent=4)
        return True
    except IOError as exc:
        logging.error(&#34;Error while writing to JSON file: %s&#34;, exc)
        return False</code></pre>
</details>
</dd>
<dt id="core.utils.Utils.write_xml"><code class="name flex">
<span>def <span class="ident">write_xml</span></span>(<span>data, file_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Write data to an XML file.</p>
<p>This method writes the provided data to an XML file at the specified file path.
If an error occurs during writing, it logs an error message and returns False.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>ET.ElementTree</code></dt>
<dd>The data to be written to the XML file.</dd>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path where the XML file will be saved.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the data was successfully written to the XML file, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def write_xml(data, file_path):
    &#34;&#34;&#34;
    Write data to an XML file.

    This method writes the provided data to an XML file at the specified file path.
    If an error occurs during writing, it logs an error message and returns False.

    Args:
        data (ET.ElementTree): The data to be written to the XML file.
        file_path (str): The path where the XML file will be saved.

    Returns:
        bool: True if the data was successfully written to the XML file, False otherwise.
    &#34;&#34;&#34;
    try:
        # Ensure the directory exists
        directory = os.path.dirname(file_path)
        if not os.path.exists(directory):
            os.makedirs(directory)

        # Write the data to the file
        data.write(file_path, encoding=&#39;utf-8&#39;, xml_declaration=True)
        return True
    except IOError as exc:
        logging.error(&#34;Error while writing to XML file: %s&#34;, exc)
        return False
    except ET.ElementTree as exc:
        logging.error(&#34;Error while creating XML file: %s&#34;, exc)
        return False</code></pre>
</details>
</dd>
<dt id="core.utils.Utils.write_yaml"><code class="name flex">
<span>def <span class="ident">write_yaml</span></span>(<span>data, file_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Write data to a YAML file.</p>
<p>This method writes the provided data to a YAML file at the specified file path.
If an error occurs during writing, it logs an error message and returns False.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code> or <code>list</code></dt>
<dd>The data to be written to the YAML file.</dd>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path where the YAML file will be saved.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the data was successfully written to the YAML file, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def write_yaml(data, file_path):
    &#34;&#34;&#34;
    Write data to a YAML file.

    This method writes the provided data to a YAML file at the specified file path.
    If an error occurs during writing, it logs an error message and returns False.

    Args:
        data (dict or list): The data to be written to the YAML file.
        file_path (str): The path where the YAML file will be saved.

    Returns:
        bool: True if the data was successfully written to the YAML file, False otherwise.
    &#34;&#34;&#34;
    try:
        # Ensure the directory exists
        directory = os.path.dirname(file_path)
        if not os.path.exists(directory):
            os.makedirs(directory)

        # Open the file and write the data to it
        with open(file_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
            yaml.safe_dump(data, file, default_flow_style=False, allow_unicode=True)
        return True
    except IOError as exc:
        # Log an error if there is an issue writing to the file
        logging.error(&#34;Error while writing to YAML file: %s&#34;, exc)
        return False
    except yaml.YAMLError as exc:
        # Log an error if there is an issue with the YAML data
        logging.error(&#34;Error while dumping data to YAML file: %s&#34;, exc)
        return False</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="core" href="index.html">core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="core.utils.Utils" href="#core.utils.Utils">Utils</a></code></h4>
<ul class="two-column">
<li><code><a title="core.utils.Utils.get_logger" href="#core.utils.Utils.get_logger">get_logger</a></code></li>
<li><code><a title="core.utils.Utils.read_file" href="#core.utils.Utils.read_file">read_file</a></code></li>
<li><code><a title="core.utils.Utils.read_ini" href="#core.utils.Utils.read_ini">read_ini</a></code></li>
<li><code><a title="core.utils.Utils.read_json" href="#core.utils.Utils.read_json">read_json</a></code></li>
<li><code><a title="core.utils.Utils.read_xml" href="#core.utils.Utils.read_xml">read_xml</a></code></li>
<li><code><a title="core.utils.Utils.read_yaml" href="#core.utils.Utils.read_yaml">read_yaml</a></code></li>
<li><code><a title="core.utils.Utils.setup_logging" href="#core.utils.Utils.setup_logging">setup_logging</a></code></li>
<li><code><a title="core.utils.Utils.write_file" href="#core.utils.Utils.write_file">write_file</a></code></li>
<li><code><a title="core.utils.Utils.write_ini" href="#core.utils.Utils.write_ini">write_ini</a></code></li>
<li><code><a title="core.utils.Utils.write_json" href="#core.utils.Utils.write_json">write_json</a></code></li>
<li><code><a title="core.utils.Utils.write_xml" href="#core.utils.Utils.write_xml">write_xml</a></code></li>
<li><code><a title="core.utils.Utils.write_yaml" href="#core.utils.Utils.write_yaml">write_yaml</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>