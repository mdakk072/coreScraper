<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>core.baseDriver API documentation</title>
<meta name="description" content="BaseDriver Module â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>core.baseDriver</code></h1>
</header>
<section id="section-intro">
<p>BaseDriver Module</p>
<p>This module provides a robust web scraping class <code><a title="core.baseDriver.BaseDriver" href="#core.baseDriver.BaseDriver">BaseDriver</a></code> using Selenium WebDriver.
The <code><a title="core.baseDriver.BaseDriver" href="#core.baseDriver.BaseDriver">BaseDriver</a></code> class includes methods to initialize, control, and interact with a web browser,
as well as utilities for handling cookies, navigating to URLs, and interacting with web elements.</p>
<h2 id="classes">Classes</h2>
<p>BaseDriver: A class that encapsulates the functionality required to perform web scraping
using Selenium WebDriver.</p>
<p>Usage Example:
from core.baseDriver import BaseDriver</p>
<pre><code>driver_path = 'path/to/your/webdriver'
base_driver = BaseDriver(driver_path=driver_path, headless=True)
base_driver.init_driver()

# Navigate to a URL
base_driver.navigate_to('https://www.example.com')

# Find an element
element = base_driver.find_element('//div[@id="example"]')

# Input text into an element
base_driver.input_text(element, 'Sample Text')

# Click an element
base_driver.click_element(element)

# Save page source to a file
base_driver.save_page('page_source.html')

# Save and load cookies
base_driver.save_cookies()
base_driver.load_cookies()

# Execute JavaScript
base_driver.execute_script('console.log("Hello, world!");')

# Clear browser storage
base_driver.clear_driver_storage()

# Close the driver
base_driver.close_driver()
</code></pre>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li>selenium</li>
<li>core.utils (for logging utility)</li>
</ul>
<p>This module requires a WebDriver executable (e.g., geckodriver for Firefox, chromedriver for Chrome)
to be installed and specified in the driver_path.</p>
<p>Author: mdakk072</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
BaseDriver Module

This module provides a robust web scraping class `BaseDriver` using Selenium WebDriver.
The `BaseDriver` class includes methods to initialize, control, and interact with a web browser,
as well as utilities for handling cookies, navigating to URLs, and interacting with web elements.

Classes:
    BaseDriver: A class that encapsulates the functionality required to perform web scraping
                using Selenium WebDriver.

Usage Example:
    from core.baseDriver import BaseDriver

    driver_path = &#39;path/to/your/webdriver&#39;
    base_driver = BaseDriver(driver_path=driver_path, headless=True)
    base_driver.init_driver()
    
    # Navigate to a URL
    base_driver.navigate_to(&#39;https://www.example.com&#39;)

    # Find an element
    element = base_driver.find_element(&#39;//div[@id=&#34;example&#34;]&#39;)
    
    # Input text into an element
    base_driver.input_text(element, &#39;Sample Text&#39;)

    # Click an element
    base_driver.click_element(element)

    # Save page source to a file
    base_driver.save_page(&#39;page_source.html&#39;)

    # Save and load cookies
    base_driver.save_cookies()
    base_driver.load_cookies()

    # Execute JavaScript
    base_driver.execute_script(&#39;console.log(&#34;Hello, world!&#34;);&#39;)

    # Clear browser storage
    base_driver.clear_driver_storage()

    # Close the driver
    base_driver.close_driver()

Dependencies:
    - selenium
    - core.utils (for logging utility)

This module requires a WebDriver executable (e.g., geckodriver for Firefox, chromedriver for Chrome) 
to be installed and specified in the driver_path.

Author: mdakk072
&#34;&#34;&#34;
import logging
import json
import os
import random
import time

from typing import List, Optional
from selenium import webdriver
from selenium.webdriver.chrome.options import Options as ChromeOptions
from selenium.webdriver.chrome.service import Service as ChromeService
from selenium.webdriver.firefox.options import Options as FirefoxOptions
from selenium.webdriver.firefox.service import Service as FirefoxService
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import WebDriverException, NoSuchElementException

from core.utils import Utils

class BaseDriver:
    &#34;&#34;&#34;
    A robust web scraping class using Selenium WebDriver.

    Attributes:
        driver_path (str): Path to the WebDriver executable.
        headless (bool): Whether to run the browser in headless mode.
        driver (Optional[webdriver.Firefox]): The Selenium WebDriver instance.
        options (webdriver.FirefoxOptions): Browser options for customization.
    &#34;&#34;&#34;

    def __init__(self, driver_path: str, headless: bool = True):
        &#34;&#34;&#34;
        Initializes the BaseDriver with the given parameters.

        Args:
            driver_path (str): Path to the WebDriver executable.
            headless (bool): Whether to run the browser in headless mode.
        &#34;&#34;&#34;
        self.logger = Utils.get_logger()
        if not self.logger:
            raise Exception(&#34;Logger not initialized&#34;)
        self.logger.debug(&#34;BaseDriver initialized with driver path: %s, headless: %s&#34;, driver_path, headless)

        self.driver_path: str = driver_path
        self.headless = headless
        self.driver: Optional[webdriver.Firefox] = None

        self.options = FirefoxOptions()
        self.options.headless = headless
        self.options.add_argument(&#34;start-maximized&#34;)
        self.options.add_argument(&#34;--disable-extensions&#34;)
        self.options.add_argument(&#34;--disable-gpu&#34;)

        self.options.set_preference(&#34;browser.cache.disk.enable&#34;, False)
        self.options.set_preference(&#34;browser.cache.memory.enable&#34;, False)
        self.options.set_preference(&#34;browser.cache.offline.enable&#34;, False)
        self.options.set_preference(&#34;network.http.use-cache&#34;, False)

    def init_driver(self):
        &#34;&#34;&#34;
        Initializes the WebDriver instance with specified options.
        &#34;&#34;&#34;
        if self.headless:
            os.environ[&#39;MOZ_HEADLESS&#39;] = &#39;1&#39;
        else:
            os.environ.pop(&#39;MOZ_HEADLESS&#39;, None)

        service = FirefoxService(executable_path=self.driver_path)
        try:
            self.driver = webdriver.Firefox(service=service, options=self.options)
            self.driver.implicitly_wait(5)
            self.logger.info(&#34;WebDriver initialized successfully.&#34;)
        except WebDriverException as e:
            self.logger.error(&#34;Failed to initialize WebDriver: %s&#34;, str(e))
            raise

    def restart_driver(self):
        &#34;&#34;&#34;
        Restarts the WebDriver instance.
        &#34;&#34;&#34;
        if self.driver:
            self.driver.quit()
            self.logger.debug(&#34;WebDriver quit successfully.&#34;)
        self.init_driver()

    def close_driver(self):
        &#34;&#34;&#34;
        Closes the browser and quits the driver.
        &#34;&#34;&#34;
        if self.driver:
            self.driver.quit()
            self.logger.info(&#34;Browser closed and driver quit.&#34;)

    def navigate_to(self, url: str):
        &#34;&#34;&#34;
        Navigates to the specified URL.

        Args:
            url (str): The URL to navigate to.
        &#34;&#34;&#34;
        try:
            if self.driver:
                self.driver.get(url)
                self.logger.info(&#34;Navigated to URL: %s&#34;, url)
        except WebDriverException as e:
            self.logger.error(&#34;Failed to navigate to URL %s: %s&#34;, url, str(e))
            raise

    def find_element(self, locator: str, by: By = By.XPATH) -&gt; Optional[webdriver.remote.webelement.WebElement]:
        &#34;&#34;&#34;
        Finds an element on the web page by specified locator.

        Args:
            locator (str): The locator of the web element to find.
            by (By): The strategy to use for locating elements (default By.XPATH).

        Returns:
            Optional[webdriver.remote.webelement.WebElement]: The web element if found, else None.
        &#34;&#34;&#34;
        try:
            element = WebDriverWait(self.driver, 10).until(EC.presence_of_element_located((by, locator)))
            self.logger.info(f&#34;Element found: {locator}&#34;)
            return element
        except Exception as e:
            self.logger.error(f&#34;Error finding element: {e}&#34;)
            return None

    def input_text(self, element, text: str):
        &#34;&#34;&#34;
        Inputs text into a specified web element with a delay to mimic human typing.

        Args:
            element: The web element to input text into.
            text (str): The text to input.
        &#34;&#34;&#34;
        try:
            for char in text:
                delay = random.uniform(0.1, 0.3)  # Adjust the range as needed for realism
                time.sleep(delay)
                element.send_keys(char)
            self.logger.debug(&#34;Text input successful into element.&#34;)
        except NoSuchElementException as e:
            self.logger.error(&#34;Failed to input text: Element not found. %s&#34;, str(e))
            raise
        except WebDriverException as e:
            self.logger.error(&#34;Error during text input: %s&#34;, str(e))
            raise

    def click_element(self, element):
        &#34;&#34;&#34;
        Clicks on a specified web element with a delay to mimic human reaction time.

        Args:
            element: The web element to click.
        &#34;&#34;&#34;
        try:
            delay = random.uniform(0.5, 1.5)  # Random delay to mimic human reaction time
            time.sleep(delay)
            element.click()
            self.logger.debug(&#34;Clicked element successfully.&#34;)
        except NoSuchElementException as e:
            self.logger.error(&#34;Failed to click: Element not found. %s&#34;, str(e))
            raise
        except WebDriverException as e:
            self.logger.error(&#34;Error during click on element: %s&#34;, str(e))
            raise

    def clear_driver_storage(self):
        &#34;&#34;&#34;
        Clears local and session storage in the browser.
        &#34;&#34;&#34;
        if self.driver:
            self.driver.execute_script(&#34;window.localStorage.clear();&#34;)
            self.driver.execute_script(&#34;window.sessionStorage.clear();&#34;)
            self.logger.debug(&#34;Local and session storage cleared.&#34;)

    def save_cookies(self):
        &#34;&#34;&#34;
        Saves browser cookies to a file.
        &#34;&#34;&#34;
        if self.driver:
            self.cookies = self.driver.get_cookies()
            with open(&#34;cookies.json&#34;, &#34;w&#34;) as f:
                f.write(json.dumps(self.cookies, indent=4))
            self.logger.debug(&#34;Cookies saved to file.&#34;)

    def load_cookies(self, cookies=None):
        &#34;&#34;&#34;
        Loads browser cookies from a file or the provided cookies.

        Args:
            cookies (Optional[List[dict]]): The cookies to load. If not provided, uses cookies from the instance.
        &#34;&#34;&#34;
        if self.driver:
            if not cookies:
                cookies = self.cookies
            if not cookies:
                self.logger.error(&#34;No cookies provided to load.&#34;)
                return
            for cookie in cookies:
                self.driver.add_cookie(cookie)
            self.logger.debug(&#34;Cookies loaded from file.&#34;)

    def save_page(self, file_path: str):
        &#34;&#34;&#34;
        Saves the current page source to a file.

        Args:
            file_path (str): The path of the file to save the page source to.
        &#34;&#34;&#34;
        if self.driver:
            with open(file_path, &#34;w&#34;) as f:
                f.write(self.driver.page_source)
            self.logger.debug(&#34;Page source saved to file.&#34;)

    def execute_script(self, script: str, *args):
        &#34;&#34;&#34;
        Executes JavaScript on the current page.

        Args:
            script (str): The JavaScript to execute.
            args: Arguments to pass to the JavaScript.
        &#34;&#34;&#34;
        if self.driver:
            return self.driver.execute_script(script, *args)
        else:
            self.logger.error(&#34;Driver not initialized.&#34;)
            return None

    # Additional methods for managing cookies, proxies, user agents, etc., can be added here.</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="core.baseDriver.BaseDriver"><code class="flex name class">
<span>class <span class="ident">BaseDriver</span></span>
<span>(</span><span>driver_path:Â str, headless:Â boolÂ =Â True)</span>
</code></dt>
<dd>
<div class="desc"><p>A robust web scraping class using Selenium WebDriver.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>driver_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the WebDriver executable.</dd>
<dt><strong><code>headless</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to run the browser in headless mode.</dd>
<dt><strong><code>driver</code></strong> :&ensp;<code>Optional[webdriver.Firefox]</code></dt>
<dd>The Selenium WebDriver instance.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>webdriver.FirefoxOptions</code></dt>
<dd>Browser options for customization.</dd>
</dl>
<p>Initializes the BaseDriver with the given parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>driver_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the WebDriver executable.</dd>
<dt><strong><code>headless</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to run the browser in headless mode.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseDriver:
    &#34;&#34;&#34;
    A robust web scraping class using Selenium WebDriver.

    Attributes:
        driver_path (str): Path to the WebDriver executable.
        headless (bool): Whether to run the browser in headless mode.
        driver (Optional[webdriver.Firefox]): The Selenium WebDriver instance.
        options (webdriver.FirefoxOptions): Browser options for customization.
    &#34;&#34;&#34;

    def __init__(self, driver_path: str, headless: bool = True):
        &#34;&#34;&#34;
        Initializes the BaseDriver with the given parameters.

        Args:
            driver_path (str): Path to the WebDriver executable.
            headless (bool): Whether to run the browser in headless mode.
        &#34;&#34;&#34;
        self.logger = Utils.get_logger()
        if not self.logger:
            raise Exception(&#34;Logger not initialized&#34;)
        self.logger.debug(&#34;BaseDriver initialized with driver path: %s, headless: %s&#34;, driver_path, headless)

        self.driver_path: str = driver_path
        self.headless = headless
        self.driver: Optional[webdriver.Firefox] = None

        self.options = FirefoxOptions()
        self.options.headless = headless
        self.options.add_argument(&#34;start-maximized&#34;)
        self.options.add_argument(&#34;--disable-extensions&#34;)
        self.options.add_argument(&#34;--disable-gpu&#34;)

        self.options.set_preference(&#34;browser.cache.disk.enable&#34;, False)
        self.options.set_preference(&#34;browser.cache.memory.enable&#34;, False)
        self.options.set_preference(&#34;browser.cache.offline.enable&#34;, False)
        self.options.set_preference(&#34;network.http.use-cache&#34;, False)

    def init_driver(self):
        &#34;&#34;&#34;
        Initializes the WebDriver instance with specified options.
        &#34;&#34;&#34;
        if self.headless:
            os.environ[&#39;MOZ_HEADLESS&#39;] = &#39;1&#39;
        else:
            os.environ.pop(&#39;MOZ_HEADLESS&#39;, None)

        service = FirefoxService(executable_path=self.driver_path)
        try:
            self.driver = webdriver.Firefox(service=service, options=self.options)
            self.driver.implicitly_wait(5)
            self.logger.info(&#34;WebDriver initialized successfully.&#34;)
        except WebDriverException as e:
            self.logger.error(&#34;Failed to initialize WebDriver: %s&#34;, str(e))
            raise

    def restart_driver(self):
        &#34;&#34;&#34;
        Restarts the WebDriver instance.
        &#34;&#34;&#34;
        if self.driver:
            self.driver.quit()
            self.logger.debug(&#34;WebDriver quit successfully.&#34;)
        self.init_driver()

    def close_driver(self):
        &#34;&#34;&#34;
        Closes the browser and quits the driver.
        &#34;&#34;&#34;
        if self.driver:
            self.driver.quit()
            self.logger.info(&#34;Browser closed and driver quit.&#34;)

    def navigate_to(self, url: str):
        &#34;&#34;&#34;
        Navigates to the specified URL.

        Args:
            url (str): The URL to navigate to.
        &#34;&#34;&#34;
        try:
            if self.driver:
                self.driver.get(url)
                self.logger.info(&#34;Navigated to URL: %s&#34;, url)
        except WebDriverException as e:
            self.logger.error(&#34;Failed to navigate to URL %s: %s&#34;, url, str(e))
            raise

    def find_element(self, locator: str, by: By = By.XPATH) -&gt; Optional[webdriver.remote.webelement.WebElement]:
        &#34;&#34;&#34;
        Finds an element on the web page by specified locator.

        Args:
            locator (str): The locator of the web element to find.
            by (By): The strategy to use for locating elements (default By.XPATH).

        Returns:
            Optional[webdriver.remote.webelement.WebElement]: The web element if found, else None.
        &#34;&#34;&#34;
        try:
            element = WebDriverWait(self.driver, 10).until(EC.presence_of_element_located((by, locator)))
            self.logger.info(f&#34;Element found: {locator}&#34;)
            return element
        except Exception as e:
            self.logger.error(f&#34;Error finding element: {e}&#34;)
            return None

    def input_text(self, element, text: str):
        &#34;&#34;&#34;
        Inputs text into a specified web element with a delay to mimic human typing.

        Args:
            element: The web element to input text into.
            text (str): The text to input.
        &#34;&#34;&#34;
        try:
            for char in text:
                delay = random.uniform(0.1, 0.3)  # Adjust the range as needed for realism
                time.sleep(delay)
                element.send_keys(char)
            self.logger.debug(&#34;Text input successful into element.&#34;)
        except NoSuchElementException as e:
            self.logger.error(&#34;Failed to input text: Element not found. %s&#34;, str(e))
            raise
        except WebDriverException as e:
            self.logger.error(&#34;Error during text input: %s&#34;, str(e))
            raise

    def click_element(self, element):
        &#34;&#34;&#34;
        Clicks on a specified web element with a delay to mimic human reaction time.

        Args:
            element: The web element to click.
        &#34;&#34;&#34;
        try:
            delay = random.uniform(0.5, 1.5)  # Random delay to mimic human reaction time
            time.sleep(delay)
            element.click()
            self.logger.debug(&#34;Clicked element successfully.&#34;)
        except NoSuchElementException as e:
            self.logger.error(&#34;Failed to click: Element not found. %s&#34;, str(e))
            raise
        except WebDriverException as e:
            self.logger.error(&#34;Error during click on element: %s&#34;, str(e))
            raise

    def clear_driver_storage(self):
        &#34;&#34;&#34;
        Clears local and session storage in the browser.
        &#34;&#34;&#34;
        if self.driver:
            self.driver.execute_script(&#34;window.localStorage.clear();&#34;)
            self.driver.execute_script(&#34;window.sessionStorage.clear();&#34;)
            self.logger.debug(&#34;Local and session storage cleared.&#34;)

    def save_cookies(self):
        &#34;&#34;&#34;
        Saves browser cookies to a file.
        &#34;&#34;&#34;
        if self.driver:
            self.cookies = self.driver.get_cookies()
            with open(&#34;cookies.json&#34;, &#34;w&#34;) as f:
                f.write(json.dumps(self.cookies, indent=4))
            self.logger.debug(&#34;Cookies saved to file.&#34;)

    def load_cookies(self, cookies=None):
        &#34;&#34;&#34;
        Loads browser cookies from a file or the provided cookies.

        Args:
            cookies (Optional[List[dict]]): The cookies to load. If not provided, uses cookies from the instance.
        &#34;&#34;&#34;
        if self.driver:
            if not cookies:
                cookies = self.cookies
            if not cookies:
                self.logger.error(&#34;No cookies provided to load.&#34;)
                return
            for cookie in cookies:
                self.driver.add_cookie(cookie)
            self.logger.debug(&#34;Cookies loaded from file.&#34;)

    def save_page(self, file_path: str):
        &#34;&#34;&#34;
        Saves the current page source to a file.

        Args:
            file_path (str): The path of the file to save the page source to.
        &#34;&#34;&#34;
        if self.driver:
            with open(file_path, &#34;w&#34;) as f:
                f.write(self.driver.page_source)
            self.logger.debug(&#34;Page source saved to file.&#34;)

    def execute_script(self, script: str, *args):
        &#34;&#34;&#34;
        Executes JavaScript on the current page.

        Args:
            script (str): The JavaScript to execute.
            args: Arguments to pass to the JavaScript.
        &#34;&#34;&#34;
        if self.driver:
            return self.driver.execute_script(script, *args)
        else:
            self.logger.error(&#34;Driver not initialized.&#34;)
            return None

    # Additional methods for managing cookies, proxies, user agents, etc., can be added here.</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="core.baseDriver.BaseDriver.clear_driver_storage"><code class="name flex">
<span>def <span class="ident">clear_driver_storage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears local and session storage in the browser.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_driver_storage(self):
    &#34;&#34;&#34;
    Clears local and session storage in the browser.
    &#34;&#34;&#34;
    if self.driver:
        self.driver.execute_script(&#34;window.localStorage.clear();&#34;)
        self.driver.execute_script(&#34;window.sessionStorage.clear();&#34;)
        self.logger.debug(&#34;Local and session storage cleared.&#34;)</code></pre>
</details>
</dd>
<dt id="core.baseDriver.BaseDriver.click_element"><code class="name flex">
<span>def <span class="ident">click_element</span></span>(<span>self, element)</span>
</code></dt>
<dd>
<div class="desc"><p>Clicks on a specified web element with a delay to mimic human reaction time.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>element</code></strong></dt>
<dd>The web element to click.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def click_element(self, element):
    &#34;&#34;&#34;
    Clicks on a specified web element with a delay to mimic human reaction time.

    Args:
        element: The web element to click.
    &#34;&#34;&#34;
    try:
        delay = random.uniform(0.5, 1.5)  # Random delay to mimic human reaction time
        time.sleep(delay)
        element.click()
        self.logger.debug(&#34;Clicked element successfully.&#34;)
    except NoSuchElementException as e:
        self.logger.error(&#34;Failed to click: Element not found. %s&#34;, str(e))
        raise
    except WebDriverException as e:
        self.logger.error(&#34;Error during click on element: %s&#34;, str(e))
        raise</code></pre>
</details>
</dd>
<dt id="core.baseDriver.BaseDriver.close_driver"><code class="name flex">
<span>def <span class="ident">close_driver</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Closes the browser and quits the driver.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_driver(self):
    &#34;&#34;&#34;
    Closes the browser and quits the driver.
    &#34;&#34;&#34;
    if self.driver:
        self.driver.quit()
        self.logger.info(&#34;Browser closed and driver quit.&#34;)</code></pre>
</details>
</dd>
<dt id="core.baseDriver.BaseDriver.execute_script"><code class="name flex">
<span>def <span class="ident">execute_script</span></span>(<span>self, script:Â str, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Executes JavaScript on the current page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>script</code></strong> :&ensp;<code>str</code></dt>
<dd>The JavaScript to execute.</dd>
<dt><strong><code>args</code></strong></dt>
<dd>Arguments to pass to the JavaScript.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_script(self, script: str, *args):
    &#34;&#34;&#34;
    Executes JavaScript on the current page.

    Args:
        script (str): The JavaScript to execute.
        args: Arguments to pass to the JavaScript.
    &#34;&#34;&#34;
    if self.driver:
        return self.driver.execute_script(script, *args)
    else:
        self.logger.error(&#34;Driver not initialized.&#34;)
        return None</code></pre>
</details>
</dd>
<dt id="core.baseDriver.BaseDriver.find_element"><code class="name flex">
<span>def <span class="ident">find_element</span></span>(<span>self, locator:Â str, by:Â selenium.webdriver.common.by.ByÂ =Â 'xpath') â€‘>Â Optional[selenium.webdriver.remote.webelement.WebElement]</span>
</code></dt>
<dd>
<div class="desc"><p>Finds an element on the web page by specified locator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>locator</code></strong> :&ensp;<code>str</code></dt>
<dd>The locator of the web element to find.</dd>
<dt><strong><code>by</code></strong> :&ensp;<code>By</code></dt>
<dd>The strategy to use for locating elements (default By.XPATH).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[webdriver.remote.webelement.WebElement]</code></dt>
<dd>The web element if found, else None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_element(self, locator: str, by: By = By.XPATH) -&gt; Optional[webdriver.remote.webelement.WebElement]:
    &#34;&#34;&#34;
    Finds an element on the web page by specified locator.

    Args:
        locator (str): The locator of the web element to find.
        by (By): The strategy to use for locating elements (default By.XPATH).

    Returns:
        Optional[webdriver.remote.webelement.WebElement]: The web element if found, else None.
    &#34;&#34;&#34;
    try:
        element = WebDriverWait(self.driver, 10).until(EC.presence_of_element_located((by, locator)))
        self.logger.info(f&#34;Element found: {locator}&#34;)
        return element
    except Exception as e:
        self.logger.error(f&#34;Error finding element: {e}&#34;)
        return None</code></pre>
</details>
</dd>
<dt id="core.baseDriver.BaseDriver.init_driver"><code class="name flex">
<span>def <span class="ident">init_driver</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes the WebDriver instance with specified options.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_driver(self):
    &#34;&#34;&#34;
    Initializes the WebDriver instance with specified options.
    &#34;&#34;&#34;
    if self.headless:
        os.environ[&#39;MOZ_HEADLESS&#39;] = &#39;1&#39;
    else:
        os.environ.pop(&#39;MOZ_HEADLESS&#39;, None)

    service = FirefoxService(executable_path=self.driver_path)
    try:
        self.driver = webdriver.Firefox(service=service, options=self.options)
        self.driver.implicitly_wait(5)
        self.logger.info(&#34;WebDriver initialized successfully.&#34;)
    except WebDriverException as e:
        self.logger.error(&#34;Failed to initialize WebDriver: %s&#34;, str(e))
        raise</code></pre>
</details>
</dd>
<dt id="core.baseDriver.BaseDriver.input_text"><code class="name flex">
<span>def <span class="ident">input_text</span></span>(<span>self, element, text:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Inputs text into a specified web element with a delay to mimic human typing.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>element</code></strong></dt>
<dd>The web element to input text into.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The text to input.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def input_text(self, element, text: str):
    &#34;&#34;&#34;
    Inputs text into a specified web element with a delay to mimic human typing.

    Args:
        element: The web element to input text into.
        text (str): The text to input.
    &#34;&#34;&#34;
    try:
        for char in text:
            delay = random.uniform(0.1, 0.3)  # Adjust the range as needed for realism
            time.sleep(delay)
            element.send_keys(char)
        self.logger.debug(&#34;Text input successful into element.&#34;)
    except NoSuchElementException as e:
        self.logger.error(&#34;Failed to input text: Element not found. %s&#34;, str(e))
        raise
    except WebDriverException as e:
        self.logger.error(&#34;Error during text input: %s&#34;, str(e))
        raise</code></pre>
</details>
</dd>
<dt id="core.baseDriver.BaseDriver.load_cookies"><code class="name flex">
<span>def <span class="ident">load_cookies</span></span>(<span>self, cookies=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads browser cookies from a file or the provided cookies.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cookies</code></strong> :&ensp;<code>Optional[List[dict]]</code></dt>
<dd>The cookies to load. If not provided, uses cookies from the instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_cookies(self, cookies=None):
    &#34;&#34;&#34;
    Loads browser cookies from a file or the provided cookies.

    Args:
        cookies (Optional[List[dict]]): The cookies to load. If not provided, uses cookies from the instance.
    &#34;&#34;&#34;
    if self.driver:
        if not cookies:
            cookies = self.cookies
        if not cookies:
            self.logger.error(&#34;No cookies provided to load.&#34;)
            return
        for cookie in cookies:
            self.driver.add_cookie(cookie)
        self.logger.debug(&#34;Cookies loaded from file.&#34;)</code></pre>
</details>
</dd>
<dt id="core.baseDriver.BaseDriver.navigate_to"><code class="name flex">
<span>def <span class="ident">navigate_to</span></span>(<span>self, url:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Navigates to the specified URL.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL to navigate to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def navigate_to(self, url: str):
    &#34;&#34;&#34;
    Navigates to the specified URL.

    Args:
        url (str): The URL to navigate to.
    &#34;&#34;&#34;
    try:
        if self.driver:
            self.driver.get(url)
            self.logger.info(&#34;Navigated to URL: %s&#34;, url)
    except WebDriverException as e:
        self.logger.error(&#34;Failed to navigate to URL %s: %s&#34;, url, str(e))
        raise</code></pre>
</details>
</dd>
<dt id="core.baseDriver.BaseDriver.restart_driver"><code class="name flex">
<span>def <span class="ident">restart_driver</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Restarts the WebDriver instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restart_driver(self):
    &#34;&#34;&#34;
    Restarts the WebDriver instance.
    &#34;&#34;&#34;
    if self.driver:
        self.driver.quit()
        self.logger.debug(&#34;WebDriver quit successfully.&#34;)
    self.init_driver()</code></pre>
</details>
</dd>
<dt id="core.baseDriver.BaseDriver.save_cookies"><code class="name flex">
<span>def <span class="ident">save_cookies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves browser cookies to a file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_cookies(self):
    &#34;&#34;&#34;
    Saves browser cookies to a file.
    &#34;&#34;&#34;
    if self.driver:
        self.cookies = self.driver.get_cookies()
        with open(&#34;cookies.json&#34;, &#34;w&#34;) as f:
            f.write(json.dumps(self.cookies, indent=4))
        self.logger.debug(&#34;Cookies saved to file.&#34;)</code></pre>
</details>
</dd>
<dt id="core.baseDriver.BaseDriver.save_page"><code class="name flex">
<span>def <span class="ident">save_page</span></span>(<span>self, file_path:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the current page source to a file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of the file to save the page source to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_page(self, file_path: str):
    &#34;&#34;&#34;
    Saves the current page source to a file.

    Args:
        file_path (str): The path of the file to save the page source to.
    &#34;&#34;&#34;
    if self.driver:
        with open(file_path, &#34;w&#34;) as f:
            f.write(self.driver.page_source)
        self.logger.debug(&#34;Page source saved to file.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="core" href="index.html">core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="core.baseDriver.BaseDriver" href="#core.baseDriver.BaseDriver">BaseDriver</a></code></h4>
<ul class="">
<li><code><a title="core.baseDriver.BaseDriver.clear_driver_storage" href="#core.baseDriver.BaseDriver.clear_driver_storage">clear_driver_storage</a></code></li>
<li><code><a title="core.baseDriver.BaseDriver.click_element" href="#core.baseDriver.BaseDriver.click_element">click_element</a></code></li>
<li><code><a title="core.baseDriver.BaseDriver.close_driver" href="#core.baseDriver.BaseDriver.close_driver">close_driver</a></code></li>
<li><code><a title="core.baseDriver.BaseDriver.execute_script" href="#core.baseDriver.BaseDriver.execute_script">execute_script</a></code></li>
<li><code><a title="core.baseDriver.BaseDriver.find_element" href="#core.baseDriver.BaseDriver.find_element">find_element</a></code></li>
<li><code><a title="core.baseDriver.BaseDriver.init_driver" href="#core.baseDriver.BaseDriver.init_driver">init_driver</a></code></li>
<li><code><a title="core.baseDriver.BaseDriver.input_text" href="#core.baseDriver.BaseDriver.input_text">input_text</a></code></li>
<li><code><a title="core.baseDriver.BaseDriver.load_cookies" href="#core.baseDriver.BaseDriver.load_cookies">load_cookies</a></code></li>
<li><code><a title="core.baseDriver.BaseDriver.navigate_to" href="#core.baseDriver.BaseDriver.navigate_to">navigate_to</a></code></li>
<li><code><a title="core.baseDriver.BaseDriver.restart_driver" href="#core.baseDriver.BaseDriver.restart_driver">restart_driver</a></code></li>
<li><code><a title="core.baseDriver.BaseDriver.save_cookies" href="#core.baseDriver.BaseDriver.save_cookies">save_cookies</a></code></li>
<li><code><a title="core.baseDriver.BaseDriver.save_page" href="#core.baseDriver.BaseDriver.save_page">save_page</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>