<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>core.baseRequest API documentation</title>
<meta name="description" content="BaseRequest Module â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>core.baseRequest</code></h1>
</header>
<section id="section-intro">
<p>BaseRequest Module</p>
<h2 id="description">Description</h2>
<p>This module defines the <code><a title="core.baseRequest.BaseRequest" href="#core.baseRequest.BaseRequest">BaseRequest</a></code> class, which provides a foundation for making HTTP requests
and handling web scraping tasks. It includes functionalities such as retries, session management,
timeout handling, and user-agent rotation to facilitate robust web scraping activities.</p>
<p>The class is designed to be extended for specific web scraping needs, allowing for customizable
request headers, proxy support, and automated request delays to mimic human interaction and avoid
blocking by web servers.</p>
<h2 id="classes">Classes</h2>
<p>BaseRequest: A base class for building web scrapers with customizable HTTP session configurations.</p>
<p>Imported Modules:
requests: For making HTTP requests.
logging: For logging activities.
random: For generating random numbers.
time: For adding delays.
itertools.cycle: For cycling through proxies and user agents.
core.utils: For utility functions including logging setup.</p>
<p>Usage Example:
from core.baseRequest import BaseRequest</p>
<pre><code>base_request = BaseRequest(base_url='https://example.com', retries=3, timeout=5.0)

# Send a GET request
response = base_request.send_request('GET', '/api/data')
print(response.json())

# Introduce a random delay
base_request.delay_action()

# Close the session
base_request.close()
</code></pre>
<h2 id="author">Author</h2>
<p>mdakk072</p>
<h2 id="date">Date</h2>
<p>11 May 2024</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
BaseRequest Module

Description:
    This module defines the `BaseRequest` class, which provides a foundation for making HTTP requests
    and handling web scraping tasks. It includes functionalities such as retries, session management,
    timeout handling, and user-agent rotation to facilitate robust web scraping activities.

    The class is designed to be extended for specific web scraping needs, allowing for customizable
    request headers, proxy support, and automated request delays to mimic human interaction and avoid
    blocking by web servers.

Classes:
    BaseRequest: A base class for building web scrapers with customizable HTTP session configurations.

Imported Modules:
    requests: For making HTTP requests.
    logging: For logging activities.
    random: For generating random numbers.
    time: For adding delays.
    itertools.cycle: For cycling through proxies and user agents.
    core.utils: For utility functions including logging setup.

Usage Example:
    from core.baseRequest import BaseRequest

    base_request = BaseRequest(base_url=&#39;https://example.com&#39;, retries=3, timeout=5.0)
    
    # Send a GET request
    response = base_request.send_request(&#39;GET&#39;, &#39;/api/data&#39;)
    print(response.json())

    # Introduce a random delay
    base_request.delay_action()

    # Close the session
    base_request.close()

Author:
    mdakk072

Date:
    11 May 2024
&#34;&#34;&#34;

import requests
import logging
from requests.adapters import HTTPAdapter
from urllib3.util import Retry
from typing import Iterator, Optional, Dict, Any, List
import random
import time
from itertools import cycle
from core.utils import Utils

class BaseRequest:
    &#34;&#34;&#34;
    A base class for making HTTP requests and parsing HTML content, designed to support 
    web scraping activities with robust features like retries, timeouts, and request customizations.

    This class provides reusable methods for common HTTP-based web scraping tasks
    and serves as a parent class for specific scraper implementations.

    Attributes:
        logger (logging.Logger): The logger for logging messages.
        session (requests.Session): The HTTP session for making requests.
        default_headers (Dict[str, str]): Default headers for requests.
        timeout (float): The timeout for HTTP requests.
        headers (Dict[str, str]): Custom headers for requests, with defaults provided.
    &#34;&#34;&#34;

    def __init__(self, base_url: Optional[str] = None, retries: int = 3, backoff_factor: float = 0.3,
                 timeout: float = 5.0, headers: Optional[Dict[str, str]] = None, proxies: Optional[List[str]] = None,
                 user_agents: Optional[List[str]] = None):
        &#34;&#34;&#34;
        Initialize the base request class with optional configurations for HTTP requests.

        Args:
            base_url (Optional[str]): The base URL for all requests.
            retries (int): The number of retries for failed requests.
            backoff_factor (float): The backoff factor to apply between retry attempts.
            timeout (float): The timeout for HTTP requests in seconds.
            headers (Optional[Dict[str, str]]): Custom headers for requests.
            proxies (Optional[List[str]]): A list of proxy servers (e.g., [&#39;http://proxy1&#39;, &#39;https://proxy2&#39;]).
            user_agents (Optional[List[str]]): A list of user agents to rotate with each request.
        &#34;&#34;&#34;
        self.logger: logging.Logger = Utils.get_logger()
        self.base_url: str = base_url if base_url is not None else &#34;&#34;
        self.retries: int = retries
        self.backoff_factor: float = backoff_factor
        self.timeout: float = timeout
        self.proxies: Optional[Iterator[str]] = cycle(proxies) if proxies else None
        self.user_agents: Optional[Iterator[str]] = cycle(user_agents) if user_agents else None
        self.session: requests.Session = requests.Session()
        retries_obj: Retry = Retry(total=retries, backoff_factor=backoff_factor, status_forcelist=[500, 502, 503, 504])
        adapter: HTTPAdapter = HTTPAdapter(max_retries=retries_obj)
        self.session.mount(&#39;http://&#39;, adapter)
        self.session.mount(&#39;https://&#39;, adapter)
        self.default_headers: Dict[str, str] = {
            &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3&#34;,
            &#34;Accept&#34;: &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#34;,
            &#34;Accept-Language&#34;: &#34;en-US,en;q=0.5&#34;,
            &#34;Accept-Encoding&#34;: &#34;gzip, deflate, br&#34;,
            &#34;Connection&#34;: &#34;keep-alive&#34;,
            &#34;Upgrade-Insecure-Requests&#34;: &#34;1&#34;,
            &#34;Cache-Control&#34;: &#34;max-age=0&#34;,
            &#34;Referer&#34;: &#34;https://www.google.com/&#34;,
            &#34;DNT&#34;: &#34;1&#34;
        }
        self.headers: Dict[str, str] = headers if headers is not None else self.default_headers

    def send_request(self, method: str, endpoint: str, **kwargs) -&gt; requests.Response:
        &#34;&#34;&#34;
        Send an HTTP request using the specified method to the specified endpoint.

        Args:
            method (str): The HTTP method to use (e.g., &#39;GET&#39;, &#39;POST&#39;).
            endpoint (str): The endpoint path to append to the base URL.
            **kwargs: Additional keyword arguments to pass to the requests method (e.g., params, json).

        Returns:
            requests.Response: The response object from the HTTP request.

        Raises:
            requests.RequestException: An error occurred during the request.
        &#34;&#34;&#34;
        url: str = self.base_url + endpoint
        headers: Dict[str, str] = {**self.default_headers, **kwargs.pop(&#39;headers&#39;, {})}
        if self.user_agents:
            headers[&#39;User-Agent&#39;] = next(self.user_agents)
        if self.proxies:
            kwargs[&#39;proxies&#39;] = {&#39;http&#39;: next(self.proxies), &#39;https&#39;: next(self.proxies)}
        try:
            response: requests.Response = self.session.request(method, url, headers=headers, timeout=self.timeout, **kwargs)
            response.raise_for_status()
            return response
        except requests.RequestException as e:
            self.logger.error(f&#34;Error during {method} request to {url}: {e}&#34;)
            raise

    def delay_action(self, min_delay: float = 1.0, max_delay: float = 3.0):
        &#34;&#34;&#34;
        Introduce a random delay to mimic human interaction and manage request rate.

        Args:
            min_delay (float): The minimum delay in seconds before making a request.
            max_delay (float): The maximum delay in seconds before making a request.
        &#34;&#34;&#34;
        delay: float = random.uniform(min_delay, max_delay)
        time.sleep(delay)
        self.logger.debug(f&#34;Action delayed for {delay} seconds.&#34;)

    def close(self):
        &#34;&#34;&#34;
        Close the HTTP session and release any resources.
        &#34;&#34;&#34;
        self.session.close()
        self.logger.info(&#34;Session closed.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="core.baseRequest.BaseRequest"><code class="flex name class">
<span>class <span class="ident">BaseRequest</span></span>
<span>(</span><span>base_url:Â Optional[str]Â =Â None, retries:Â intÂ =Â 3, backoff_factor:Â floatÂ =Â 0.3, timeout:Â floatÂ =Â 5.0, headers:Â Optional[Dict[str,Â str]]Â =Â None, proxies:Â Optional[List[str]]Â =Â None, user_agents:Â Optional[List[str]]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>A base class for making HTTP requests and parsing HTML content, designed to support
web scraping activities with robust features like retries, timeouts, and request customizations.</p>
<p>This class provides reusable methods for common HTTP-based web scraping tasks
and serves as a parent class for specific scraper implementations.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>logger</code></strong> :&ensp;<code>logging.Logger</code></dt>
<dd>The logger for logging messages.</dd>
<dt><strong><code>session</code></strong> :&ensp;<code>requests.Session</code></dt>
<dd>The HTTP session for making requests.</dd>
<dt><strong><code>default_headers</code></strong> :&ensp;<code>Dict[str, str]</code></dt>
<dd>Default headers for requests.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code></dt>
<dd>The timeout for HTTP requests.</dd>
<dt><strong><code>headers</code></strong> :&ensp;<code>Dict[str, str]</code></dt>
<dd>Custom headers for requests, with defaults provided.</dd>
</dl>
<p>Initialize the base request class with optional configurations for HTTP requests.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base_url</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The base URL for all requests.</dd>
<dt><strong><code>retries</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of retries for failed requests.</dd>
<dt><strong><code>backoff_factor</code></strong> :&ensp;<code>float</code></dt>
<dd>The backoff factor to apply between retry attempts.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code></dt>
<dd>The timeout for HTTP requests in seconds.</dd>
<dt><strong><code>headers</code></strong> :&ensp;<code>Optional[Dict[str, str]]</code></dt>
<dd>Custom headers for requests.</dd>
<dt><strong><code>proxies</code></strong> :&ensp;<code>Optional[List[str]]</code></dt>
<dd>A list of proxy servers (e.g., ['http://proxy1', 'https://proxy2']).</dd>
<dt><strong><code>user_agents</code></strong> :&ensp;<code>Optional[List[str]]</code></dt>
<dd>A list of user agents to rotate with each request.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseRequest:
    &#34;&#34;&#34;
    A base class for making HTTP requests and parsing HTML content, designed to support 
    web scraping activities with robust features like retries, timeouts, and request customizations.

    This class provides reusable methods for common HTTP-based web scraping tasks
    and serves as a parent class for specific scraper implementations.

    Attributes:
        logger (logging.Logger): The logger for logging messages.
        session (requests.Session): The HTTP session for making requests.
        default_headers (Dict[str, str]): Default headers for requests.
        timeout (float): The timeout for HTTP requests.
        headers (Dict[str, str]): Custom headers for requests, with defaults provided.
    &#34;&#34;&#34;

    def __init__(self, base_url: Optional[str] = None, retries: int = 3, backoff_factor: float = 0.3,
                 timeout: float = 5.0, headers: Optional[Dict[str, str]] = None, proxies: Optional[List[str]] = None,
                 user_agents: Optional[List[str]] = None):
        &#34;&#34;&#34;
        Initialize the base request class with optional configurations for HTTP requests.

        Args:
            base_url (Optional[str]): The base URL for all requests.
            retries (int): The number of retries for failed requests.
            backoff_factor (float): The backoff factor to apply between retry attempts.
            timeout (float): The timeout for HTTP requests in seconds.
            headers (Optional[Dict[str, str]]): Custom headers for requests.
            proxies (Optional[List[str]]): A list of proxy servers (e.g., [&#39;http://proxy1&#39;, &#39;https://proxy2&#39;]).
            user_agents (Optional[List[str]]): A list of user agents to rotate with each request.
        &#34;&#34;&#34;
        self.logger: logging.Logger = Utils.get_logger()
        self.base_url: str = base_url if base_url is not None else &#34;&#34;
        self.retries: int = retries
        self.backoff_factor: float = backoff_factor
        self.timeout: float = timeout
        self.proxies: Optional[Iterator[str]] = cycle(proxies) if proxies else None
        self.user_agents: Optional[Iterator[str]] = cycle(user_agents) if user_agents else None
        self.session: requests.Session = requests.Session()
        retries_obj: Retry = Retry(total=retries, backoff_factor=backoff_factor, status_forcelist=[500, 502, 503, 504])
        adapter: HTTPAdapter = HTTPAdapter(max_retries=retries_obj)
        self.session.mount(&#39;http://&#39;, adapter)
        self.session.mount(&#39;https://&#39;, adapter)
        self.default_headers: Dict[str, str] = {
            &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3&#34;,
            &#34;Accept&#34;: &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#34;,
            &#34;Accept-Language&#34;: &#34;en-US,en;q=0.5&#34;,
            &#34;Accept-Encoding&#34;: &#34;gzip, deflate, br&#34;,
            &#34;Connection&#34;: &#34;keep-alive&#34;,
            &#34;Upgrade-Insecure-Requests&#34;: &#34;1&#34;,
            &#34;Cache-Control&#34;: &#34;max-age=0&#34;,
            &#34;Referer&#34;: &#34;https://www.google.com/&#34;,
            &#34;DNT&#34;: &#34;1&#34;
        }
        self.headers: Dict[str, str] = headers if headers is not None else self.default_headers

    def send_request(self, method: str, endpoint: str, **kwargs) -&gt; requests.Response:
        &#34;&#34;&#34;
        Send an HTTP request using the specified method to the specified endpoint.

        Args:
            method (str): The HTTP method to use (e.g., &#39;GET&#39;, &#39;POST&#39;).
            endpoint (str): The endpoint path to append to the base URL.
            **kwargs: Additional keyword arguments to pass to the requests method (e.g., params, json).

        Returns:
            requests.Response: The response object from the HTTP request.

        Raises:
            requests.RequestException: An error occurred during the request.
        &#34;&#34;&#34;
        url: str = self.base_url + endpoint
        headers: Dict[str, str] = {**self.default_headers, **kwargs.pop(&#39;headers&#39;, {})}
        if self.user_agents:
            headers[&#39;User-Agent&#39;] = next(self.user_agents)
        if self.proxies:
            kwargs[&#39;proxies&#39;] = {&#39;http&#39;: next(self.proxies), &#39;https&#39;: next(self.proxies)}
        try:
            response: requests.Response = self.session.request(method, url, headers=headers, timeout=self.timeout, **kwargs)
            response.raise_for_status()
            return response
        except requests.RequestException as e:
            self.logger.error(f&#34;Error during {method} request to {url}: {e}&#34;)
            raise

    def delay_action(self, min_delay: float = 1.0, max_delay: float = 3.0):
        &#34;&#34;&#34;
        Introduce a random delay to mimic human interaction and manage request rate.

        Args:
            min_delay (float): The minimum delay in seconds before making a request.
            max_delay (float): The maximum delay in seconds before making a request.
        &#34;&#34;&#34;
        delay: float = random.uniform(min_delay, max_delay)
        time.sleep(delay)
        self.logger.debug(f&#34;Action delayed for {delay} seconds.&#34;)

    def close(self):
        &#34;&#34;&#34;
        Close the HTTP session and release any resources.
        &#34;&#34;&#34;
        self.session.close()
        self.logger.info(&#34;Session closed.&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="core.baseRequest.BaseRequest.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close the HTTP session and release any resources.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;
    Close the HTTP session and release any resources.
    &#34;&#34;&#34;
    self.session.close()
    self.logger.info(&#34;Session closed.&#34;)</code></pre>
</details>
</dd>
<dt id="core.baseRequest.BaseRequest.delay_action"><code class="name flex">
<span>def <span class="ident">delay_action</span></span>(<span>self, min_delay:Â floatÂ =Â 1.0, max_delay:Â floatÂ =Â 3.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Introduce a random delay to mimic human interaction and manage request rate.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>min_delay</code></strong> :&ensp;<code>float</code></dt>
<dd>The minimum delay in seconds before making a request.</dd>
<dt><strong><code>max_delay</code></strong> :&ensp;<code>float</code></dt>
<dd>The maximum delay in seconds before making a request.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delay_action(self, min_delay: float = 1.0, max_delay: float = 3.0):
    &#34;&#34;&#34;
    Introduce a random delay to mimic human interaction and manage request rate.

    Args:
        min_delay (float): The minimum delay in seconds before making a request.
        max_delay (float): The maximum delay in seconds before making a request.
    &#34;&#34;&#34;
    delay: float = random.uniform(min_delay, max_delay)
    time.sleep(delay)
    self.logger.debug(f&#34;Action delayed for {delay} seconds.&#34;)</code></pre>
</details>
</dd>
<dt id="core.baseRequest.BaseRequest.send_request"><code class="name flex">
<span>def <span class="ident">send_request</span></span>(<span>self, method:Â str, endpoint:Â str, **kwargs) â€‘>Â requests.models.Response</span>
</code></dt>
<dd>
<div class="desc"><p>Send an HTTP request using the specified method to the specified endpoint.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>The HTTP method to use (e.g., 'GET', 'POST').</dd>
<dt><strong><code>endpoint</code></strong> :&ensp;<code>str</code></dt>
<dd>The endpoint path to append to the base URL.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments to pass to the requests method (e.g., params, json).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>requests.Response</code></dt>
<dd>The response object from the HTTP request.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>requests.RequestException</code></dt>
<dd>An error occurred during the request.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_request(self, method: str, endpoint: str, **kwargs) -&gt; requests.Response:
    &#34;&#34;&#34;
    Send an HTTP request using the specified method to the specified endpoint.

    Args:
        method (str): The HTTP method to use (e.g., &#39;GET&#39;, &#39;POST&#39;).
        endpoint (str): The endpoint path to append to the base URL.
        **kwargs: Additional keyword arguments to pass to the requests method (e.g., params, json).

    Returns:
        requests.Response: The response object from the HTTP request.

    Raises:
        requests.RequestException: An error occurred during the request.
    &#34;&#34;&#34;
    url: str = self.base_url + endpoint
    headers: Dict[str, str] = {**self.default_headers, **kwargs.pop(&#39;headers&#39;, {})}
    if self.user_agents:
        headers[&#39;User-Agent&#39;] = next(self.user_agents)
    if self.proxies:
        kwargs[&#39;proxies&#39;] = {&#39;http&#39;: next(self.proxies), &#39;https&#39;: next(self.proxies)}
    try:
        response: requests.Response = self.session.request(method, url, headers=headers, timeout=self.timeout, **kwargs)
        response.raise_for_status()
        return response
    except requests.RequestException as e:
        self.logger.error(f&#34;Error during {method} request to {url}: {e}&#34;)
        raise</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="core" href="index.html">core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="core.baseRequest.BaseRequest" href="#core.baseRequest.BaseRequest">BaseRequest</a></code></h4>
<ul class="">
<li><code><a title="core.baseRequest.BaseRequest.close" href="#core.baseRequest.BaseRequest.close">close</a></code></li>
<li><code><a title="core.baseRequest.BaseRequest.delay_action" href="#core.baseRequest.BaseRequest.delay_action">delay_action</a></code></li>
<li><code><a title="core.baseRequest.BaseRequest.send_request" href="#core.baseRequest.BaseRequest.send_request">send_request</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>